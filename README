The GNU Hurd
============

This is not the GNU Hurd.  But it might become it at some day.

The intention is to port the GNU Hurd to run on the L4 microkernel.

This is work in progress.


How to build
------------

Building the code is straight forward:

$ autoreconf -f -i -s
$ ./configure --enable-maintainer-mode --prefix=/l4
$ make
$ make install
$ mkdir /l4/boot
$ install -s laden/laden /l4/boot
$ install -s wortel/wortel /l4/boot
$ install -s physmem/physmem /l4/boot
$ install -s task/task /l4/boot

You need at least automake 1.7 and autoconf 2.53.  Note that the
binaries MUST be stripped, otherwise they will overlap in memory (or
you can adjust the load addresses).


Installation on ia32
--------------------

Prerequisites: Pistachio-0.4 (or CVS) with the patch below.  You can
find information about how to download the Pistachio source
distribution (which includes the kernel and sigma0) at the following
URL:

http://www.l4ka.org/projects/pistachio/download.php

sigma0 must be built with a different link base than the default value
0x20000, because that conflicts with GRUB (on ia32).  I have
successfully used a link base of 0x40000.  Use the configure option
--with-s0-linkbase=0x40000 when configuring the user space of the L4
distribution.

You only need the ia32-kernel and sigma0 binary from the L4
distribution.  You may want to install the other programs and
utilities as well to test your L4 kernel, though.

Then set up GRUB to boot laden as the kernel, and the L4 kernel,
sigma0, wortel (the rootserver), physmem and task as its modules (in
that order).  Also, add some dummy entries for the not-yet-existing
modules deva, deva-store and rootfs (just repeat the task server entry
another three times)

Try the debug option (-D) to laden and wortel to see some output from
them.  They are silent by default.

Here is an example menu.lst file for GNU GRUB:

title The GNU Hurd on L4
root (hd0,0)
kernel /boot/laden -D
module /boot/ia32-kernel
module /boot/sigma0
module /boot/wortel -D
module /boot/physmem
module /boot/task
module /boot/task
module /boot/task
module /boot/task


Pistachio Patch
---------------

The following patch fixes a problem with IPC propagation and with
receiving from any local thread.

2004-10-28  Marcus Brinkmann  <marcus@gnu.org>

	* src/api/v4/ipc.cc (SYS_IPC): If receiving from any local
	thread, look up the first sending local thread.

2004-10-23  Marcus Brinkmann  <marcus@gnu.org>

	* src/api/v4/ipc.cc (SYS_IPC): If propagating, modify the
	originator's partner to wait for the new receiver if the
	originator is in a closed wait for the sender. Check if the
	receiver is waiting for the current sender, not for the
	originator thread.

Index: kernel/src/api/v4/ipc.cc
===================================================================
RCS file: /public-cvs/pistachio/kernel/src/api/v4/ipc.cc,v
retrieving revision 1.57.4.6
diff -u -r1.57.4.6 ipc.cc
--- kernel/src/api/v4/ipc.cc	3 Jun 2004 13:58:57 -0000	1.57.4.6
+++ kernel/src/api/v4/ipc.cc	23 Oct 2004 00:33:45 -0000
@@ -292,6 +292,9 @@
 		 && (current->get_space() == virt_sender->get_space() ||
 		     current->get_space() == to_tcb->get_space()))
 	    {
+		if (virt_sender->get_state().is_waiting() &&
+		    virt_sender->get_partner() == sender_id)
+		  virt_sender->set_partner(to_tid);
 		sender_id = current->get_virtual_sender();
 	    }
 	    else
@@ -313,7 +316,7 @@
 	// optimized for receive and wait any
 	if (EXPECT_FALSE(
 	    (!to_tcb->get_state().is_waiting())  ||
-	    ( to_tcb->get_partner() != sender_id &&
+	    ( to_tcb->get_partner() != current->get_global_id() &&
 	      !to_tcb->get_partner().is_anythread() &&
 	      !( to_tcb->get_partner().is_anylocalthread() && 
 		 to_tcb->get_space() == current->get_space() ) ) ))
@@ -517,9 +520,24 @@ SYS_IPC (threadid_t to_tid, threadid_t f
 	    }
 	}
 	else
-	{	/* anylocal */
-#warning wait_local incorrect
-	    from_tcb = current->send_head;
+	{
+	    /* anylocal */
+
+	    tcb_t *head = current->send_head;
+	    from_tcb = NULL;
+
+	    if (head)
+	    {
+	        tcb_t *tcb = head;
+	  
+	        do
+		{
+		    if (tcb->get_space () == current->get_space ())
+		        from_tcb = tcb;
+		    tcb = tcb->send_list.next;
+		}
+	        while (!from_tcb && tcb != head);
+	    }
 	}
 
 	TRACE_IPC("receive phase curr=%t, from=%t\n", current, from_tcb);

