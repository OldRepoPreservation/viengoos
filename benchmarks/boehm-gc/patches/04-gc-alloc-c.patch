#! /bin/sh
patch -p1 -f $* < $0
exit $?

Instrument gc code.

--- gc/alloc.c~	2007-06-22 04:40:30.000000000 +0200
+++ gc/alloc.c	2008-06-18 16:51:20.000000000 +0200
@@ -24,6 +24,69 @@
 #   include <sys/types.h>
 # endif
 
+uint64_t gc_time;
+
+static inline uint64_t
+now (void)
+{
+  struct timeval t;
+  struct timezone tz;
+
+  if (gettimeofday( &t, &tz ) == -1)
+    return 0;
+  return (t.tv_sec * 1000000 + t.tv_usec);
+
+}
+
+static int timing;
+
+static uint64_t
+start_timing (const char *func, int lineno)
+{
+  static const char *timing_func;
+  static int timing_lineno;
+
+  if (timing)
+    {
+      printf ("Timing for %s:%d but start_timing called from %s:%d\n",
+	      timing_func, timing_lineno, func, lineno);
+      assert (! timing);
+    }
+
+  timing_func = func;
+  timing_lineno = lineno;
+
+  timing = 1;
+
+  return now ();
+}
+
+static void
+end_timing (const char *func, int lineno, uint64_t start)
+{
+  uint64_t end = now ();
+
+  if (! timing)
+    {
+      printf ("Timing not started by end_timing called from %s:%d!\n",
+	      func, lineno);
+      assert (! timing);
+    }
+  timing = 0;
+
+  assert (start <= end);
+  gc_time += end - start;
+}
+
+#define start_timing()						\
+  do {								\
+    uint64_t start = start_timing (__FUNCTION__, __LINE__)
+
+#define end_timing()				\
+    end_timing (__FUNCTION__, __LINE__, start);	\
+  } while (0)
+
+
 /*
  * Separate free lists are maintained for different sized objects
  * up to MAXOBJBYTES.
@@ -256,6 +319,8 @@
             n_partial_gcs = 0;
             return;
         } else {
+	  start_timing ();
+
 #   	  ifdef PARALLEL_MARK
 	    GC_wait_for_reclaim();
 #   	  endif
@@ -266,6 +331,7 @@
      		  (unsigned long)GC_gc_no+1,
 		  (long)GC_bytes_allocd);
 	    }
+
 	    GC_promote_black_lists();
 	    (void)GC_reclaim_all((GC_stop_func)0, TRUE);
 	    GC_clear_marks();
@@ -275,7 +341,11 @@
           } else {
             n_partial_gcs++;
           }
+
+	  end_timing ();
 	}
+
+	start_timing ();
         /* We try to mark with the world stopped.	*/
         /* If we run out of time, this turns into	*/
         /* incremental marking.			*/
@@ -294,6 +364,8 @@
 	        GC_n_attempts++;
 	    }
 	}
+
+	end_timing ();
     }
 }
 
@@ -325,6 +397,10 @@
 	   "Initiating full world-stop collection %lu after %ld allocd bytes\n",
 	   (unsigned long)GC_gc_no+1, (long)GC_bytes_allocd);
     }
+
+    GC_bool ret = true;
+    start_timing ();
+
     GC_promote_black_lists();
     /* Make sure all blocks have been reclaimed, so sweep routines	*/
     /* don't see cleared mark bits.					*/
@@ -337,7 +413,8 @@
  	if ((GC_find_leak || stop_func != GC_never_stop_func)
 	    && !GC_reclaim_all(stop_func, FALSE)) {
 	    /* Aborted.  So far everything is still consistent.	*/
-	    return(FALSE);
+	    ret = FALSE;
+	    break;
 	}
     GC_invalidate_mark_state();  /* Flush mark stack.	*/
     GC_clear_marks();
@@ -354,7 +431,8 @@
 	GC_unpromote_black_lists();
       } /* else we claim the world is already still consistent.  We'll 	*/
         /* finish incrementally.					*/
-      return(FALSE);
+      ret = FALSE;
+      break;
     }
     GC_finish_collection();
     if (GC_print_stats) {
@@ -362,7 +440,9 @@
         GC_log_printf("Complete collection took %lu msecs\n",
                   MS_TIME_DIFF(current_time,start_time));
     }
-    return(TRUE);
+
+    end_timing ();
+    return ret;
 }
 
 
@@ -390,6 +470,8 @@
     
     if (GC_dont_gc) return;
     if (GC_incremental && GC_collection_in_progress()) {
+	start_timing ();
+
     	for (i = GC_deficit; i < GC_RATE*n; i++) {
     	    if (GC_mark_some((ptr_t)0)) {
     	        /* Need to finish a collection */
@@ -415,6 +497,8 @@
     	}
     	if (GC_deficit > 0) GC_deficit -= GC_RATE*n;
 	if (GC_deficit < 0) GC_deficit = 0;
+
+	end_timing ();
     } else {
         GC_maybe_gc();
     }
@@ -1021,3 +1105,30 @@
     
     return(*flh);
 }
+
+
+void
+GC_dump_stats (void)
+{
+  printf ("GC: "
+#ifdef THREADS
+	  "multi-threaded"
+#else
+	  "single threaded"
+#endif
+	  ", %s, "
+#ifndef PARALLEL_MARK
+	  "non-"
+#endif
+	  "parallel mark, dirty bits %smaintained\n",
+	  TRUE_INCREMENTAL ? "true incremental" :
+	  GC_incremental ? "generational" : "stop the world",
+	  GC_dirty_maintained ? "" : "not ");
+  printf("%d collections\n", (int) GC_gc_no);
+  printf ("%lld.%03lld seconds spent collecting\n",
+	  gc_time / 1000000, (gc_time % 1000000) / 1000);
+  printf("Heap size: %d (%d kb)\n",
+	 GC_get_heap_size(), GC_get_heap_size() / 1024);
+  printf("Total bytes allocated: %d (%d kb)\n",
+	 GC_get_total_bytes (), GC_get_total_bytes () / 1024);
+}

