\chapter{Booting}

A multiboot-compliant bootloader, for example GNU GRUB, loads the
loader program \texttt{laden}, the kernel, $\sigma_0$, the rootserver
and further modules.  The loader is started, patches the kernel
interface page, and starts the kernel.  The kernel starts $\sigma_0$
and the rootserver.  The rootserver has to deal with the other
modules.


\section{System bootstrap}

The initial part of the boot procedure is system specific.


\subsection{Booting the ia32}

On the ia32, the BIOS will be one of the first things to run.
Eventually, the BIOS will start the bootloader.  The Hurd requires a
multiboot-compliant bootloader, such as GNU GRUB.  A typical
configuration file entry in the \verb/menu.list/ file of GNU GRUB will
look like this:

\begin{verbatim}
title = The GNU Hurd on L4
root = (hd0,0)
kernel = /boot/laden
module = /boot/ia32-kernel
module = /boot/sigma0
module = /boot/wortel
module = /boot/physmem
module = /boot/task
module = /boot/deva
module = /boot/deva-drivers
module = /boot/rootfs
\end{verbatim}

GNU GRUB loads the binary image files into memory and jumps to the
entry point of \texttt{laden}.


\section{The loader \texttt{laden}}

\texttt{laden} is a multiboot compliant kernel from the perspective of
GNU GRUB.  It expects at least three modules.  The first module is the
L4 kernel image, the second module is the $\sigma_0$ server image, and
the third module is the rootserver image.

\begin{comment}
  Later, the L4 kernel will support the optional UTCB paging server
  $\sigma_1$, which has to be treated like the other initial servers
  by \texttt{laden}.  A command line option to \texttt{laden} will
  allow the user to specify if the third module is the rootserver or
  $\sigma_1$.  If $\sigma_1$ is used, the rootserver is the fourth
  module in the list.
\end{comment}

\texttt{laden} copies (or moves) the three executable images to the
right location in memory, according to their respective ELF headers.
It also initializes the BSS section to zero.

\begin{comment}
  Laden has to deal with overlapping source and destination memory
  areas in an intelligent way.  It currently will detect such
  situations, but is not always able to find a solution, even if one
  exists.
  
  If a memory area stretches out to the very last page addressible in
  32 bit, the high address of the memory descriptor will overflow.
  This is in fact the behaviour of \texttt{kickstart}.  \texttt{laden}
  currently truncates such an area by one page.  This needs
  clarification in the L4 standard.
\end{comment}

Then it searches for the kernel interface page (KIP) in the L4 kernel
image and modifies it in the following way:

\begin{itemize}
\item The memory descriptors are filled in according to the memory
  layout of the system.  On ia32, this information is -- at least
  partially -- provided by GNU GRUB.

  \begin{comment}
    GNU GRUB seems to omit information about the memory that is shared
    with the VGA card.  \texttt{laden} creates a special entry for
    that region, overriding any previous memory descriptor.
  \end{comment}
  
\item The start and end addresses and the entry point of the initial
  servers are filled in.

  \begin{comment}
    A future version of L4 should support adding information about the
    UTCB area of the initial rootserver as well.  Until then, the
    rootserver has no clean way to create a new thread (a hack is used
    by the rootserver to calculate the UTCB addresses for other
    threads).
  \end{comment}

\item The \verb/boot_info/ field is initialized.

  \begin{comment}
    The \verb/boot_info/ field is currently set to the GNU GRUB
    \verb/multiboot_info/ structure.  This only works for the ia32
    architecture of course.  We might want to have a more architecture
    independent way to pass the information about further modules to
    the rootserver.  We also might want to gather the information
    provided by GNU GRUB in a single page (if it is not).
  \end{comment}
\end{itemize}


\section{The L4 kernel}

The L4 kernel initializes itself and then creates the address spaces
and threads for the initial servers $\sigma_0$ and the rootserver.  It
maps all physical memory idempotently into $\sigma_0$, and sets the
pager of the rootserver thread to $\sigma_0$.  Then it starts the
initial servers.


\section{The initial server $\sigma_0$}

$\sigma_0$ acts as the pager for the rootserver, answering page fault
messages by mapping the page at the fault address idempotently in the
rootserver.

\begin{comment}
  $\sigma_0$ can also be used directly by sending messages to it,
  according to the $\sigma_0$ RPC protocol.  This is used by the kernel
  to allocate reserved memory, but can also be used by the user to
  explicitely allocate more memory than single pages indirectly via
  page faults.
\end{comment}

The thread ID of $\sigma_0$ is (\verb/UserBase/, 1).

\begin{comment}
  We will write all thread IDs in the form (\verb/thread nr/,
  \verb/version/).
\end{comment}

Any fpage will only be provided to one thread.  $\sigma_0$ will return
an error if another thread attempts to map or manipulate an fpage that
has already been given to some other thread, even if both threads
reside in the same address space.


\section{The initial server $\sigma_1$}

$\sigma_1$ is intended to provide a paging service for UTCB memory.
This will allow orthogonal persistence to be implemented.  It is not
yet supported.

The thread ID of $\sigma_1$ is (\verb/UserBase/ + 1, 1).


\section{The rootserver wortel}
\label{rootserver}
\label{wortel}

The rootserver that L4 started is the only task in the system which
threads can perform privileged system calls.  So the rootserver must
provide wrappers for the system calls to other unprivileged system
tasks.

\begin{comment}
  For this, a simple authentication scheme is required.  The
  rootserver can keep a small, statically allocated table of threads
  which are granted access to the system call wrappers.  The caller
  could provide the index in the table for fast O(1) lookup instead
  linear search.  Threads with access could be allowed to add other
  threads or change existing table entries.  The same scheme can be
  used in the device driver framework.
  
  The rootserver should have one thread per CPU, and run at a high
  priority.
\end{comment}

Our rootserver is called wortel, and also bootstraps the operating
system.  Wortel thus acts as a simple manager OS and as a bootloader
program.

\begin{comment}
  Ideally, there would be a real manager OS on top of L4 in which you
  can run different sand-boxed operating systems.  Wortel implements
  only some rudimentary features such a system would provide: Access
  to the system memory and execution of privileged L4 system calls.

  If you had such a real manager OS, then this manager OS would start
  a bootloader to boot up a sand-boxed operating system.  For
  simplicity, wortel currently implements such a bootloader for the
  Hurd system.  Eventually, the code should be split to allow both
  components to develop independently.
\end{comment}

The rootserver has the following initial state:

\begin{itemize}
\item Its thread ID is (\verb/UserBase/ + 2, 1).

\item The priority is set to the 255, the maximum value.

  \begin{comment}
    The rootserver, or at least the system call wrapper, should run at
    a very high priority.
  \end{comment}

\item The instruction pointer \verb/%eip/ is set to the entry point,
all other registers are undefined (including the stack pointer).

\item The pager is set to $\sigma_0$.
  
\item The exception handler is set to \verb/nilthread/.
  
\item The scheduler is set to the rootserver thread itself.
\end{itemize}

So the first thing the rootserver has to do is to set up a simple
stack.

Then the rootserver should evaluate the \verb/boot_info/ field in the
KIP to find the information about the other modules.  It should parse
the information and create the desired initial tasks of the operating
system.  The Hurd uses a boot script syntax to allow to pass
information about other initial tasks and the root tasks to each
initial task in a generalized manner.

\begin{comment}
  The exact number and type of initial tasks necessary to boot the
  Hurd are not yet known.  Chances are that this list includes the
  \texttt{task} server, the physical memory server, the device
  servers, and the boot filesystem.  The boot filesystem might be a
  small simple filesystem, which also includes the device drivers
  needed to access the real root filesystem.
\end{comment}


\section{The physical memory server physmem}

The physical memory server is the first component of the actual Hurd
system that is started (wortel serves as a manager OS in the
background, and its presence is of no relevance to Hurd programs other
than the fundamental core servers described in this chapter).  It
provides memory management routines that allow tasks in the Hurd
system to be self-paged.

The rootserver moves the physical memory server executable image to
its ELF load address (and initializes the BSS section to zero),
creates a new address space and several threads in this address space,
starts the first thread and then maps all the fpages covering the
executable image 1:1 into the address space at the first pagefault
(the fpage on which the thread faulted is mapped last - this makes the
thread fault repeatedly until the whole image is mapped).

\begin{comment}
  Wortel should follow the \texttt{exec()} protocol to startup the new
  task as closely as possible.  However, there is little that wortel
  can provide to physmem in this terms.
\end{comment}

So, the physical memory server runs on mapped memory in its own
address space, but the virtual addresses of its executable image
coincede with the physical addresses.

Then, in a private protocol between wortel and physmem, the following
happens:

\begin{enumerate}
\item Physmem requests all system memory from wortel.  Wortel maps the
  memory from $\sigma_0$ and maps it to physmem.

  \begin{comment}
    The memory is mapped, not granted, to allow wortel (of which we
    think as a manager OS here) to unmap and recover the memory in
    case of a (possibly forced) system shutdown.
  \end{comment}

\item For each module that has not been used yet, wortel requests a
  capability in physmem that can be used to map in pages from the
  range of memory that the module occupies.  These capabilities should
  implement the same pager interface that mappable files implement.
  
  \begin{comment}
    The idea is that these capabilities can be used in the
    \texttt{exec()} protocol to start up the tasks for these modules.
    If a module is not a task, the capability can be used to access
    the module data by mapping it into the address space like a file.
    Physmem can even swap out pages that back these objects on memory
    pressure.

    So, the physical memory server is in fact a simple filesystem for
    these initial tasks, usable only for mapping operations.

    Wortel can then start up the other tasks in the module list
    using the normal \texttt{exec()} protocol.
  \end{comment}
\end{enumerate}

The result is that all tasks except for the rootserver can be started
and manage their memory through physmem like normal Hurd tasks.

Later on, wortel will provide physmem with further information
retrieved from the task and deva servers.


\section{The task server}

The task server is the second Hurd server started by wortel.  Its
responsibility is to keep track of allocation of task and thread IDs
in the system, and manage related resources (recording and restricting
CPU usage).

FIXME More has to be said here.


\section{The device access server deva}

The device access server deva is the third Hurd server started by
wortel.  It implements access to a low-level device driver framework
in a way that transparently fits into the overall Hurd system.  This
means that access to device drivers is managed via capabilities, and
that physmem containers are used for data exchange between a
user-level application and a low-level device driver.

It also provides system integration services to the underlying
low-level device driver framework.  In particular, it intermediates
access to privileged resources and provides device drivers and related
data from the systems filesystem.

FIXME More has to be said here.


\section{The device access server archive}

The device access server needs to load device drivers before a root
filesystem service is available.  In particular, it needs to be able
to provide device drivers for the root filesystem to the device driver
framework.

The device access server archive is an archive of device drivers that
is loaded by the bootloader and contains drivers necessary to run the
root filesystem.


\section{The root filesystem}

The root filesystem is the fourth and last Hurd server started by
wortel.  After the root filesystem starts up and has exchanged the
necessary bootstrap information with deva, it starts up the rest of
the operating system services from its filesystem.

The root filesystem is the first program to actually run in a proper
environment, given that it can access device drivers, task and physmem
services.

\begin{comment}
  From the time the root filesystem starts up, the bootstrap continues
  roughly as it is implemented in the Hurd running on GNU Mach.
\end{comment}
